cpdtr <- read.csv(paste0(dir,"coupon_detail_train.csv"))

cpltr <- read.csv(paste0(dir,"coupon_list_train.csv"))

cplte <- read.csv(paste0(dir,"coupon_list_test.csv"))

ulist <- read.csv(paste0(dir,"user_list.csv"))

cpvtr <- read.csv(paste0(dir,"coupon_visit_train.csv"))

# Removing the rows with PURCHASEFLAG = 1, since the data is already included in coupon_detail

cpvtr <- cpvtr[cpvtr$PURCHASE_FLG!=1,c("VIEW_COUPON_ID_hash","USER_ID_hash")]

# Need to fix 'VALIDPERIOD'. Add 1 to the period since the difference calculated does not include the starting day

cpltr$VALIDPERIOD[is.na(cpltr$VALIDPERIOD)] <- max(cpltr$VALIDPERIOD, na.rm = T)

cpltr$VALIDPERIOD <- cpltr$VALIDPERIOD + 1

cpltr$VALIDPERIOD <- as.factor(cpltr$VALIDPERIOD)

cplte$VALIDPERIOD[is.na(cplte$VALIDPERIOD)] <- max(cplte$VALIDPERIOD, na.rm = T)

cplte$VALIDPERIOD <- cplte$VALIDPERIOD+1

cplte$VALIDPERIOD <- as.factor(cplte$VALIDPERIOD)

# The USABlE_DATES columns contain the values 0,1and 2. However, we are unable to ascertain the meaning behind thevalue '2'. Hence we are changing it all to '1' and making the columns binary with '0' meaning coupon not usable and '1' meaning coupon usable.

for (i in 12:20) {

cpltr[is.na(cpltr[,i]),i] <- 1; cpltr[cpltr[,i]>1,i] <- 1

cplte[is.na(cplte[,i]),i] <- 1; cplte[cplte[,i]>1,i] <- 1

}

cpltr$USABLE_DATE_sum <- rowSums(cpltr[,12:20])

cplte$USABLE_DATE_sum <- rowSums(cplte[,12:20])

# start train set by merging coupon_detail_train and coupon_list_train

# to get USER_ID_hash by coupon

train <- merge(cpdtr,cpltr)

train <- train[,c("COUPON_ID_hash","USER_ID_hash",

"GENRE_NAME","PRICE_RATE", "DISPPERIOD",

"large_area_name","small_area_name","VALIDPERIOD","USABLE_DATE_sum","USABLE_DATE_MON", "USABLE_DATE_TUE", "USABLE_DATE_WED", "USABLE_DATE_THU", "USABLE_DATE_FRI", "USABLE_DATE_SAT", "USABLE_DATE_SUN", "USABLE_DATE_HOLIDAY", "USABLE_DATE_BEFORE_HOLIDAY")]

# Add USER_ID_hash column to make test set similar to train

cplte$USER_ID_hash <- "test"

cplte_feat <- cplte[,c("COUPON_ID_hash","USER_ID_hash",

"GENRE_NAME","PRICE_RATE", "DISPPERIOD",

"large_area_name","small_area_name","VALIDPERIOD","USABLE_DATE_sum","USABLE_DATE_MON", "USABLE_DATE_TUE", "USABLE_DATE_WED", "USABLE_DATE_THU", "USABLE_DATE_FRI", "USABLE_DATE_SAT", "USABLE_DATE_SUN", "USABLE_DATE_HOLIDAY", "USABLE_DATE_BEFORE_HOLIDAY")]

train <- rbind(train,cplte_feat)

# Since there aren't many coupons with DISPPERIOD greater than 7, we will combine them all to one category '8'

train$DISPPERIOD[train$DISPPERIOD > 7] <- 8

#convert the factors to columns of 0's and 1's

train <- cbind(train[,c(1,2)],model.matrix(~ -1 + .,train[,-c(1,2)], contrasts.arg=lapply(train[,names(which(sapply(train[,-c(1,2)], is.factor)==TRUE))], contrasts, contrasts=FALSE)))

#separate the test from train following factor column conversion

test <- train[train$USER_ID_hash=="test",]

test <- test[,-2]

train <- train[train$USER_ID_hash!="test",]

#Numeric attributes cosine multiplication factors set to 1

#train$DISCOUNT_PRICE <- 1

#train$DISPPERIOD <- 1

#train$USABLE_DATE_sum <- 1

# Create starting uchar for all users initialized to zero

uchar <- data.frame(USER_ID_hash=ulist[,"USER_ID_hash"])

uchar <- cbind(uchar,matrix(0, nrow=dim(uchar)[1], ncol=(dim(train)[2] -2)))

names(uchar) <- names(train)[2:dim(train)[2]]

# Incorporate the purchase training data from train, use sum function

uchar <- aggregate(.~USER_ID_hash, data=rbind(uchar,train[,-1]),FUN=mean)

# Add visit training data in chunks due to large dataset

imax <- dim(cpvtr)[1]

i2 <- 1

while (i2 < imax) { # this loop takes a few minutes

i1 <- i2

i2 <- i1 + 100000

if (i2 > imax) i2 <- imax

cat("Merging coupon visit data i1=",i1," i2=",i2,"\n")

trainv <- merge(cpvtr[i1:i2,],cpltr, by.x="VIEW_COUPON_ID_hash", by.y="COUPON_ID_hash")

trainv <- trainv[,c("VIEW_COUPON_ID_hash","USER_ID_hash",

"GENRE_NAME","PRICE_RATE", "DISPPERIOD",

"large_area_name","small_area_name","VALIDPERIOD","USABLE_DATE_sum","USABLE_DATE_MON", "USABLE_DATE_TUE", "USABLE_DATE_WED", "USABLE_DATE_THU", "USABLE_DATE_FRI", "USABLE_DATE_SAT", "USABLE_DATE_SUN", "USABLE_DATE_HOLIDAY", "USABLE_DATE_BEFORE_HOLIDAY")]

#same treatment as with coupon_detail train data

#trainv$DISCOUNT_PRICE <- 1;train$DISPPERIOD <- 1;train$USABLE_DATE_sum <- 1;trainv[is.na(trainv)] <- 1

trainv <- cbind(trainv[,c(1,2)],model.matrix(~ -1 + .,trainv[,-c(1,2)],

contrasts.arg=lapply(trainv[,names(which(sapply(trainv[,-c(1,2)], is.factor)==TRUE))],

contrasts, contrasts=FALSE)))

# Since coupon visits history has much less influence on future coupon purchase than actual purchase history, we will give less weight to coupon_visits

couponVisitFactor <- 0.2

trainv[,3:dim(trainv)[2]] <- trainv[,3:dim(trainv)[2]] * couponVisitFactor

uchar <- aggregate(.~USER_ID_hash, data=rbind(uchar,trainv[,-1]),FUN=mean)

}

# Calculate cosine similarity by performing matrix multiplication of the user profile and the coupon profile

require(Matrix)

score = as.matrix(uchar[,2:ncol(uchar)]) %*% t(as.matrix(test[,2:ncol(test)]))

# Order the list of coupons according to similairties and take only first 10 coupons

uchar$PURCHASED_COUPONS <- do.call(rbind, lapply(1:nrow(uchar),FUN=function(i){

purchased_cp <- paste(test$COUPON_ID_hash[order(score[i,], decreasing = TRUE)][1:10],collapse=" ")

return(purchased_cp)

}))

# Make submission

submission <- uchar[,c("USER_ID_hash","PURCHASED_COUPONS")]

submission$PURCHASED_COUPONS[rowSums(score)==0] <- ""

write.csv(submission, file="submit.csv", row.names=FALSE)
